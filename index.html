<!DOCTYPE html>
<html>

<head>
  <title>Sheets Test</title>
  <style>

    * {
      box-sizing: border-box;
    }

    html, body {
      width: 100vw;
      height: 100vh;
      margin: 0;
      overflow: hidden;
      font-family: Arial, Helvetica, sans-serif
    }

    body {
      display: grid;
      grid-template-rows: 1fr min-content;
    }

    h2 {
      background: black;
      color: white;
      padding: 10px 20px; 
      margin: 0;
    }

    table {
      border: 1px solid black;
      border-right: none;
      border-bottom: none;
      font-size: 14px;
    }

    td, th {
        padding: 5px 10px;
        border: 1px solid #000;
        border-top: none;
        border-left: none;
    }

    /* Sticky Header Rows */
    tr:first-child {
      position: sticky;
      top: 0;
      min-height: 30px;
      z-index: 2;
    }

    /* Sticky Columns */

    .sticky {
      position: sticky;
      left: 0;
    }

    .nested {
      position: sticky;
      top: 27px;
    }

    th {
      background: rgb(50, 50, 50);
      color: white;
      border-right: 1px solid black;
    }

    th > small {
      font-size: 80%;
      font-weight: 400;
    }

    main {
      overflow: auto;
      width: 100%;
    }

    td {
      background: white;
    }

    td small {
      color: rgb(45, 45, 45);
    }

    td[value="undefined"] {
      background: black;
    }

    td[value="TRUE"], td[value="FALSE"], td[value="true"], td[value="false"] {
      font-size:0;
    }

    td[value="TRUE"]:before, td[value="true"]:before {
      content: "✅";
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    td[value="FALSE"]:before, td[value="false"]:before {
      content: "❌";
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    td[value=""] {
      background: black;
    }
       

    #tabs {
      border-top: 1px solid black;
      width: 100vw;
      display: flex;
      overflow-x: auto;
      background: white;
      font-size: 90%;
    }

    #tabs div {
      cursor: pointer;
      border: 1px solid #000;
      border-top: none;
      border-left: none;
      padding: 10px 16px;
    }

    #tabs span {
      font-weight: bold;
    }

    #tabs > [selected] {
      color: rgb(8, 86, 255);
      background: rgb(225, 235, 255);
    }

  </style>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script lang="javascript" src="https://cdn.jsdelivr.net/npm/xlsx"></script>

</head>

<body>
  <main>
    <table cellpadding="0" cellspacing="0" ></table>
  </main>

  <div id="tabs"></div>

  <script type="module">

    const nColsSticky = 3

    import ecephysRec from './ecephys_recording.json' assert { type: 'json' };
    import ecephysSort from './ecephys_sorting.json' assert { type: 'json' };
    import icephys from './icephys.json' assert { type: 'json' };
    import ophysImg from './ophys_imaging.json' assert { type: 'json' };
    import ophysSeg from './ophys_segmentation.json' assert { type: 'json' };
    import behavior from './behavior.json' assert { type: 'json' };

    const id = '13ikozn6XrOGdWGa_vyxH3MZu4NkN7f4ArHonPLvb9I0'

    const tabs = document.getElementById('tabs')
    const table = document.querySelector('table')
    const stickyTable = document.createElement('table')

    const main = document.querySelector('main')

    let tables = {
        'Ecephys - Recording': ecephysRec,
        'Ecephys - Sorting': ecephysSort,
        'Icephys': icephys,
        'Ophys - Imaging': ophysImg,
        'Ophys - Segmentation': ophysSeg,
        'Behavior': behavior
    }


    const overviewCols = ['Type']

    const totals = {}

    const overviewTable = Object.entries(tables).map(([Type, t]) => {
      t.columns = t[0] ? Object.keys(t[0]) : []

      const stats = t.reduce((acc, cell) => {
          Object.keys(cell).forEach(k => {
            if (typeof cell[k] === 'boolean') {
              if (!overviewCols.includes(k)) overviewCols.push(k)
              if (!acc[k]) acc[k] = 0
              if (!totals[k]) totals[k] = { value: 0, total: 0}

              if(cell[k]) {
                acc[k]++
                totals[k].value++
              }

              totals[k].total++
            }
          })

          return acc
      }, {})

      return { Type, total: t.length, ...stats }
    })


    for (let k in totals) {
      totals[k] = getPercent(totals[k].value, totals[k].total)
    }

    overviewTable.push({
      Type: "Total",
      ...totals,
    })

    const guideValue = 'NWB GUIDE'
    const guideIdx = overviewCols.findIndex((v) => v === guideValue)
    overviewCols.splice(guideIdx, 1)

    console.log(overviewTable)

    overviewTable.columns = [...overviewCols, guideValue]

    tables = {
      Overview: overviewTable,
      ...tables
    }

    function getPercent(value, total) {
      return `${value}<small>${value && total ? ` (${(100 * value / total).toFixed(1)}%)` : ''}</small>`
    }

    function createCell(value, { total }) {
      const td = document.createElement('td')

      if (typeof value === 'string') {
        const [title, subtitle] = value.split('-')
        td.innerHTML = `${title}<br><small>${subtitle ?? ""}</small>`
      } 
      
      else {
        td.innerHTML = getPercent(value, total)
      }

      td.setAttribute('value', value)
      
      return td
    }

    function addColumnsToTable (table, info, nColsSticky) {

      let merged = null;
      let headerRowSize = 1
      const nestedRowInfo = []

      // Derive nested headers
      const headers = {}

      const formatHeader = 'Format'
      const versionsHeader = 'Versions'
      const cols = info.columns
      const formatIdx = cols.findIndex((v) => v === formatHeader)
      const versionsIdx = cols.findIndex((v) => v === versionsHeader)


      // Update format column to include versions as subtitles
      if (formatIdx !== -1 && versionsIdx !== -1) {
        info.forEach(row => {
          if (row[versionsHeader]) row[formatHeader] += ` - ${row[versionsHeader]}`
        })

        cols.splice(versionsIdx, 1)
      }      

      cols.forEach(str => {

        const [ title, subtitle ] = str.split('-')

        const consolidated = headers[title]

        if (subtitle) {
          headerRowSize = 2
          nestedRowInfo.push(subtitle)
          if (consolidated) consolidated.push(str)
          else {
            headers[title] = [ str ]
          }
        } else headers[str] = true
      })

      // Add general headers
      const tr = document.createElement('tr')

      const headerEls = Object.entries(headers).map(([cell, info], i) => {
        const th = document.createElement('th')
        const isMerged = info !== true
        if (isMerged) th.setAttribute('colspan',  info.length)
        else th.setAttribute('rowspan',  headerRowSize)
        th.innerText = cell
        return th
      }).flat()

      tr.append(...headerEls)

      table.append(tr)


      // Add nested headers
      if (nestedRowInfo.length) {
          const tr = document.createElement('tr')
          tr.classList.add('nested')
          tr.append(...nestedRowInfo.map(cell => {
            const th = document.createElement('th')
            th.innerText = cell
            return th
          }))
          table.append(tr)
      }

      const rows = info.map(cell => {
        const tr = document.createElement('tr')
        tr.append(...Object.entries(headers).map(([header, info]) => {
          return (info === true) ? createCell(cell[header], cell) : info.map(key => createCell(cell[key], cell))
        }).flat().filter(o => !!o))
        return tr
      })

      const makeSticky = (row) => {
        row.slice(0, nColsSticky).reduce((acc, cell) => {
          cell.classList.add('sticky')
          cell.style.left = `${acc}px`
          return acc + cell.getBoundingClientRect().width
        }, 0)
      }

      table.append(...rows)


      rows.forEach(r => {
        makeSticky(headerEls)
        makeSticky(Array.from(r.children))
      })
    }

    async function updateTable(sheet) {

      table.innerText = ''

      const info = await tables[sheet]

      addColumnsToTable(table, info, sheet === 'Overview' ? 1 : nColsSticky)

    }

    tabs.append(...Object.keys(tables).map(sheet => {
      const span = document.createElement('span')
      span.innerText = sheet
      const div = document.createElement('div')
      div.onclick = () => updateTable(sheet)
      div.append(span)
      return div
    }))

    updateTable(Object.keys(tables)[0])

  </script>
</body>

</html>